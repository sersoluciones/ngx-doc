<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>@sersol/ngx documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">@sersol/ngx documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content module">
                   <div class="content-data">



<ol class="breadcrumb">
    <li>Modules</li>
    <li>VirtualScrollerModule</li>
</ol>

<div class="text-center module-graph-container">
    <div id="module-graph-svg">
        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.44.1 (20200629.0846)
 -->
<!-- Title: dependencies Pages: 1 -->
<svg width="504pt" height="284pt"
 viewBox="0.00 0.00 504.00 284.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 280)">
<title>dependencies</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-280 500,-280 500,4 -4,4"/>
<text text-anchor="start" x="227.01" y="-42.4" font-family="sans-serif" font-weight="bold" font-size="14.00">Legend</text>
<polygon fill="#ffffb3" stroke="transparent" points="14,-10 14,-30 34,-30 34,-10 14,-10"/>
<text text-anchor="start" x="37.63" y="-15.4" font-family="sans-serif" font-size="14.00"> &#160;Declarations</text>
<polygon fill="#8dd3c7" stroke="transparent" points="127,-10 127,-30 147,-30 147,-10 127,-10"/>
<text text-anchor="start" x="150.73" y="-15.4" font-family="sans-serif" font-size="14.00"> &#160;Module</text>
<polygon fill="#80b1d3" stroke="transparent" points="213,-10 213,-30 233,-30 233,-10 213,-10"/>
<text text-anchor="start" x="236.78" y="-15.4" font-family="sans-serif" font-size="14.00"> &#160;Bootstrap</text>
<polygon fill="#fdb462" stroke="transparent" points="310,-10 310,-30 330,-30 330,-10 310,-10"/>
<text text-anchor="start" x="333.67" y="-15.4" font-family="sans-serif" font-size="14.00"> &#160;Providers</text>
<polygon fill="#fb8072" stroke="transparent" points="406,-10 406,-30 426,-30 426,-10 406,-10"/>
<text text-anchor="start" x="429.73" y="-15.4" font-family="sans-serif" font-size="14.00"> &#160;Exports</text>
<g id="clust1" class="cluster">
<title>cluster_VirtualScrollerModule</title>
<polygon fill="none" stroke="black" stroke-dasharray="1,5" points="148,-70 148,-268 348,-268 348,-70 148,-70"/>
</g>
<g id="clust5" class="cluster">
<title>cluster_VirtualScrollerModule_exports</title>
<polygon fill="none" stroke="black" points="156,-208 156,-260 340,-260 340,-208 156,-208"/>
</g>
<g id="clust2" class="cluster">
<title>cluster_VirtualScrollerModule_declarations</title>
<polygon fill="none" stroke="black" points="157,-78 157,-130 339,-130 339,-78 157,-78"/>
</g>
<!-- VirtualScrollerComponent -->
<g id="node1" class="node">
<title>VirtualScrollerComponent</title>
<polygon fill="#ffffb3" stroke="black" points="330.8,-122 165.2,-122 165.2,-86 330.8,-86 330.8,-122"/>
<text text-anchor="middle" x="248" y="-99.8" font-family="Times,serif" font-size="14.00">VirtualScrollerComponent</text>
</g>
<!-- VirtualScrollerModule -->
<g id="node2" class="node">
<title>VirtualScrollerModule</title>
<polygon fill="#8dd3c7" stroke="black" points="319.52,-187 316.52,-191 295.52,-191 292.52,-187 176.48,-187 176.48,-151 319.52,-151 319.52,-187"/>
<text text-anchor="middle" x="248" y="-164.8" font-family="Times,serif" font-size="14.00">VirtualScrollerModule</text>
</g>
<!-- VirtualScrollerComponent&#45;&gt;VirtualScrollerModule -->
<g id="edge1" class="edge">
<title>VirtualScrollerComponent&#45;&gt;VirtualScrollerModule</title>
<path fill="none" stroke="black" d="M248,-122.11C248,-122.11 248,-140.99 248,-140.99"/>
<polygon fill="black" stroke="black" points="244.5,-140.99 248,-150.99 251.5,-140.99 244.5,-140.99"/>
</g>
<!-- VirtualScrollerComponent  -->
<g id="node3" class="node">
<title>VirtualScrollerComponent </title>
<polygon fill="#fb8072" stroke="black" points="332.3,-252 163.7,-252 163.7,-216 332.3,-216 332.3,-252"/>
<text text-anchor="middle" x="248" y="-229.8" font-family="Times,serif" font-size="14.00">VirtualScrollerComponent </text>
</g>
<!-- VirtualScrollerModule&#45;&gt;VirtualScrollerComponent  -->
<g id="edge2" class="edge">
<title>VirtualScrollerModule&#45;&gt;VirtualScrollerComponent </title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M248,-187.11C248,-187.11 248,-205.99 248,-205.99"/>
<polygon fill="black" stroke="black" points="244.5,-205.99 248,-215.99 251.5,-205.99 244.5,-205.99"/>
</g>
</g>
</svg>

    </div>
    <i id="fullscreen" class="icon ion-ios-resize module-graph-fullscreen-btn" aria-hidden="true"></i>
    <div class="btn-group">
        <button id="zoom-in" class="btn btn-default btn-sm">Zoom in</button>
        <button id="reset" class="btn btn-default btn-sm">Reset</button>
        <button id="zoom-out" class="btn btn-default btn-sm">Zoom out</button>
    </div>
</div>
<script src="../js/libs/svg-pan-zoom.min.js"></script>
<script src="../js/svg-pan-zoom.controls.js"></script>

<ul class="nav nav-tabs" role="tablist">
    <li  class="active" >
        <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
    </li>
    <li >
        <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
    </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">

        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/form/select/virtual-scroll/virtual-scroll.ts</code>
        </p>




        <div class="container-fluid module">
            <div class="row">
                <div class="col-sm-3">
                    <h3>Declarations<a href="https://angular.io/api/core/NgModule#declarations" target="_blank"
                            title="Official documentation about module declarations"><span class="icon ion-ios-information-circle-outline"></span></a></h3>
                    <ul class="list-group">
                        <li class="list-group-item">
                            <a href="../components/VirtualScrollerComponent.html">VirtualScrollerComponent</a>
                        </li>
                    </ul>
                </div>
                <div class="col-sm-3">
                    <h3>Exports<a href="https://angular.io/api/core/NgModule#exports" target="_blank" title="Official documentation about module exports"><span
                                class="icon ion-ios-information-circle-outline"></a></h3>
                    <ul class="list-group">
                        <li class="list-group-item">
                            <a href="../components/VirtualScrollerComponent.html">VirtualScrollerComponent</a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>


    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">// tslint:disable: member-ordering
import {
    Component,
    ContentChild,
    ElementRef,
    EventEmitter,
    Inject,
    Optional,
    Input,
    NgModule,
    NgZone,
    OnChanges,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ChangeDetectorRef,
    InjectionToken
} from &#x27;@angular/core&#x27;;

import { PLATFORM_ID } from &#x27;@angular/core&#x27;;
import { isPlatformServer } from &#x27;@angular/common&#x27;;

import { CommonModule } from &#x27;@angular/common&#x27;;

import * as tween from &#x27;@tweenjs/tween.js&#x27;;
import { VirtualScrollerDefaultOptions } from &#x27;./defaultoptions&#x27;;
import { IPageInfo } from &#x27;./ipageinfo&#x27;;
import { IViewport } from &#x27;./iviewport&#x27;;

import { WrapGroupDimensions } from &#x27;./wrapgroupdimensions&#x27;;
import { WrapGroupDimension } from &#x27;./wrapgroupdimension&#x27;;

import { IDimensions } from &#x27;./idimension&#x27;;





export function VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY(): VirtualScrollerDefaultOptions {
    return {
        scrollThrottlingTime: 0,
        scrollDebounceTime: 0,
        scrollAnimationTime: 750,
        checkResizeInterval: 1000,
        resizeBypassRefreshThreshold: 5,
        modifyOverflowStyleOfParentScroll: true,
        stripedTable: false
    };
}

@Component({
    selector: &#x27;virtual-scroller,[virtualScroller]&#x27;,
    exportAs: &#x27;virtualScroller&#x27;,
    template: &#x60;
    &lt;div class&#x3D;&quot;total-padding&quot; #invisiblePadding&gt;&lt;/div&gt;
    &lt;div class&#x3D;&quot;scrollable-content&quot; #content&gt;
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/div&gt;
  &#x60;,
    // tslint:disable-next-line: no-host-metadata-property
    host: {
        &#x27;[class.horizontal]&#x27;: &#x27;horizontal&#x27;,
        &#x27;[class.vertical]&#x27;: &#x27;!horizontal&#x27;,
        &#x27;[class.selfScroll]&#x27;: &#x27;!parentScroll&#x27;
    },
    styles: [&#x60;
    :host {
      position: relative;
	  display: block;
      -webkit-overflow-scrolling: touch;
    }

	:host.horizontal.selfScroll {
      overflow-y: visible;
      overflow-x: auto;
	}
	:host.vertical.selfScroll {
      overflow-y: auto;
      overflow-x: visible;
	}

    .scrollable-content {
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      max-width: 100vw;
      max-height: 100vh;
      position: absolute;
    }

	.scrollable-content ::ng-deep &gt; * {
		box-sizing: border-box;
	}

	:host.horizontal {
		white-space: nowrap;
	}

	:host.horizontal .scrollable-content {
		display: flex;
	}

	:host.horizontal .scrollable-content ::ng-deep &gt; * {
		flex-shrink: 0;
		flex-grow: 0;
		white-space: initial;
	}

    .total-padding {
      width: 1px;
      opacity: 0;
    }

    :host.horizontal .total-padding {
      height: 100%;
    }
  &#x60;]
})
export class VirtualScrollerComponent implements OnInit, OnChanges, OnDestroy {
    public viewPortItems: any[];
    public window &#x3D; window;

    public get viewPortInfo(): IPageInfo {
        const pageInfo: IViewport &#x3D; this.previousViewPort || &lt;any&gt;{};
        return {
            startIndex: pageInfo.startIndex || 0,
            endIndex: pageInfo.endIndex || 0,
            scrollStartPosition: pageInfo.scrollStartPosition || 0,
            scrollEndPosition: pageInfo.scrollEndPosition || 0,
            maxScrollPosition: pageInfo.maxScrollPosition || 0,
            startIndexWithBuffer: pageInfo.startIndexWithBuffer || 0,
            endIndexWithBuffer: pageInfo.endIndexWithBuffer || 0
        };
    }

    @Input()
    public executeRefreshOutsideAngularZone &#x3D; false;

    protected _enableUnequalChildrenSizes &#x3D; false;
    @Input()
    public get enableUnequalChildrenSizes(): boolean {
        return this._enableUnequalChildrenSizes;
    }
    public set enableUnequalChildrenSizes(value: boolean) {
        if (this._enableUnequalChildrenSizes &#x3D;&#x3D;&#x3D; value) {
            return;
        }

        this._enableUnequalChildrenSizes &#x3D; value;
        this.minMeasuredChildWidth &#x3D; undefined;
        this.minMeasuredChildHeight &#x3D; undefined;
    }

    @Input()
    public useMarginInsteadOfTranslate &#x3D; false;

    @Input()
    public modifyOverflowStyleOfParentScroll: boolean;

    @Input()
    public stripedTable: boolean;

    @Input()
    public scrollbarWidth: number;

    @Input()
    public scrollbarHeight: number;

    @Input()
    public childWidth: number;

    @Input()
    public childHeight: number;

    @Input()
    public ssrChildWidth: number;

    @Input()
    public ssrChildHeight: number;

    @Input()
    public ssrViewportWidth &#x3D; 1920;

    @Input()
    public ssrViewportHeight &#x3D; 1080;

    protected _bufferAmount &#x3D; 0;
    @Input()
    public get bufferAmount(): number {
        if (typeof (this._bufferAmount) &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; this._bufferAmount &gt;&#x3D; 0) {
            return this._bufferAmount;
        } else {
            return this.enableUnequalChildrenSizes ? 5 : 0;
        }
    }
    public set bufferAmount(value: number) {
        this._bufferAmount &#x3D; value;
    }

    @Input()
    public scrollAnimationTime: number;

    @Input()
    public resizeBypassRefreshThreshold: number;

    protected _scrollThrottlingTime: number;
    @Input()
    public get scrollThrottlingTime(): number {
        return this._scrollThrottlingTime;
    }
    public set scrollThrottlingTime(value: number) {
        this._scrollThrottlingTime &#x3D; value;
        this.updateOnScrollFunction();
    }

    protected _scrollDebounceTime: number;
    @Input()
    public get scrollDebounceTime(): number {
        return this._scrollDebounceTime;
    }
    public set scrollDebounceTime(value: number) {
        this._scrollDebounceTime &#x3D; value;
        this.updateOnScrollFunction();
    }

    protected onScroll: () &#x3D;&gt; void;
    protected updateOnScrollFunction(): void {
        if (this.scrollDebounceTime) {
            this.onScroll &#x3D; &lt;any&gt;this.debounce(() &#x3D;&gt; {
                this.refresh_internal(false);
            }, this.scrollDebounceTime);
        } else if (this.scrollThrottlingTime) {
            this.onScroll &#x3D; &lt;any&gt;this.throttleTrailing(() &#x3D;&gt; {
                this.refresh_internal(false);
            }, this.scrollThrottlingTime);
        } else {
            this.onScroll &#x3D; () &#x3D;&gt; {
                this.refresh_internal(false);
            };
        }
    }

    protected checkScrollElementResizedTimer: number;
    protected _checkResizeInterval: number;
    @Input()
    public get checkResizeInterval(): number {
        return this._checkResizeInterval;
    }
    public set checkResizeInterval(value: number) {
        if (this._checkResizeInterval &#x3D;&#x3D;&#x3D; value) {
            return;
        }

        this._checkResizeInterval &#x3D; value;
        this.addScrollEventHandlers();
    }

    protected _items: any[] &#x3D; [];
    @Input()
    public get items(): any[] {
        return this._items;
    }
    public set items(value: any[]) {
        if (value &#x3D;&#x3D;&#x3D; this._items) {
            return;
        }

        this._items &#x3D; value || [];
        this.refresh_internal(true);
    }

    @Input()
    public compareItems: (item1: any, item2: any) &#x3D;&gt; boolean &#x3D; (item1: any, item2: any) &#x3D;&gt; item1 &#x3D;&#x3D;&#x3D; item2;

    protected _horizontal: boolean;
    @Input()
    public get horizontal(): boolean {
        return this._horizontal;
    }
    public set horizontal(value: boolean) {
        this._horizontal &#x3D; value;
        this.updateDirection();
    }

    protected revertParentOverscroll(): void {
        const scrollElement &#x3D; this.getScrollElement();
        if (scrollElement &amp;&amp; this.oldParentScrollOverflow) {
            scrollElement.style[&#x27;overflow-y&#x27;] &#x3D; this.oldParentScrollOverflow.y;
            scrollElement.style[&#x27;overflow-x&#x27;] &#x3D; this.oldParentScrollOverflow.x;
        }

        this.oldParentScrollOverflow &#x3D; undefined;
    }

    protected oldParentScrollOverflow: { x: string, y: string };
    protected _parentScroll: Element | Window;
    @Input()
    public get parentScroll(): Element | Window {
        return this._parentScroll;
    }
    public set parentScroll(value: Element | Window) {
        if (this._parentScroll &#x3D;&#x3D;&#x3D; value) {
            return;
        }

        this.revertParentOverscroll();
        this._parentScroll &#x3D; value;
        this.addScrollEventHandlers();

        const scrollElement &#x3D; this.getScrollElement();
        if (this.modifyOverflowStyleOfParentScroll &amp;&amp; scrollElement !&#x3D;&#x3D; this.element.nativeElement) {
            this.oldParentScrollOverflow &#x3D; { x: scrollElement.style[&#x27;overflow-x&#x27;], y: scrollElement.style[&#x27;overflow-y&#x27;] };
            scrollElement.style[&#x27;overflow-y&#x27;] &#x3D; this.horizontal ? &#x27;visible&#x27; : &#x27;auto&#x27;;
            scrollElement.style[&#x27;overflow-x&#x27;] &#x3D; this.horizontal ? &#x27;auto&#x27; : &#x27;visible&#x27;;
        }
    }

    @Output()
    public vsUpdate: EventEmitter&lt;any[]&gt; &#x3D; new EventEmitter&lt;any[]&gt;();

    @Output()
    public vsChange: EventEmitter&lt;IPageInfo&gt; &#x3D; new EventEmitter&lt;IPageInfo&gt;();

    @Output()
    public vsStart: EventEmitter&lt;IPageInfo&gt; &#x3D; new EventEmitter&lt;IPageInfo&gt;();

    @Output()
    public vsEnd: EventEmitter&lt;IPageInfo&gt; &#x3D; new EventEmitter&lt;IPageInfo&gt;();

    @ViewChild(&#x27;content&#x27;, { read: ElementRef, static: false })
    protected contentElementRef: ElementRef;

    @ViewChild(&#x27;invisiblePadding&#x27;, { read: ElementRef, static: false })
    protected invisiblePaddingElementRef: ElementRef;

    @ContentChild(&#x27;header&#x27;, { read: ElementRef, static: false })
    protected headerElementRef: ElementRef;

    @ContentChild(&#x27;container&#x27;, { read: ElementRef, static: false })
    protected containerElementRef: ElementRef;

    public ngOnInit(): void {
        this.addScrollEventHandlers();
    }

    public ngOnDestroy(): void {
        this.removeScrollEventHandlers();
        this.revertParentOverscroll();
    }

    public ngOnChanges(changes: any): void {
        const indexLengthChanged &#x3D; this.cachedItemsLength !&#x3D;&#x3D; this.items.length;
        this.cachedItemsLength &#x3D; this.items.length;

        const firstRun: boolean &#x3D; !changes.items || !changes.items.previousValue || changes.items.previousValue.length &#x3D;&#x3D;&#x3D; 0;
        this.refresh_internal(indexLengthChanged || firstRun);
    }


    public ngDoCheck(): void {
        if (this.cachedItemsLength !&#x3D;&#x3D; this.items.length) {
            this.cachedItemsLength &#x3D; this.items.length;
            this.refresh_internal(true);
            return;
        }

        if (this.previousViewPort &amp;&amp; this.viewPortItems &amp;&amp; this.viewPortItems.length &gt; 0) {
            let itemsArrayChanged &#x3D; false;
            for (let i &#x3D; 0; i &lt; this.viewPortItems.length; ++i) {
                if (!this.compareItems(this.items[this.previousViewPort.startIndexWithBuffer + i], this.viewPortItems[i])) {
                    itemsArrayChanged &#x3D; true;
                    break;
                }
            }
            if (itemsArrayChanged) {
                this.refresh_internal(true);
            }
        }
    }

    public refresh(): void {
        this.refresh_internal(true);
    }

    public invalidateAllCachedMeasurements(): void {
        this.wrapGroupDimensions &#x3D; {
            maxChildSizePerWrapGroup: [],
            numberOfKnownWrapGroupChildSizes: 0,
            sumOfKnownWrapGroupChildWidths: 0,
            sumOfKnownWrapGroupChildHeights: 0
        };

        this.minMeasuredChildWidth &#x3D; undefined;
        this.minMeasuredChildHeight &#x3D; undefined;

        this.refresh_internal(false);
    }

    public invalidateCachedMeasurementForItem(item: any): void {
        if (this.enableUnequalChildrenSizes) {
            const index &#x3D; this.items &amp;&amp; this.items.indexOf(item);
            if (index &gt;&#x3D; 0) {
                this.invalidateCachedMeasurementAtIndex(index);
            }
        } else {
            this.minMeasuredChildWidth &#x3D; undefined;
            this.minMeasuredChildHeight &#x3D; undefined;
        }

        this.refresh_internal(false);
    }

    public invalidateCachedMeasurementAtIndex(index: number): void {
        if (this.enableUnequalChildrenSizes) {
            const cachedMeasurement &#x3D; this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];
            if (cachedMeasurement) {
                this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] &#x3D; undefined;
                --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -&#x3D; cachedMeasurement.childWidth || 0;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -&#x3D; cachedMeasurement.childHeight || 0;
            }
        } else {
            this.minMeasuredChildWidth &#x3D; undefined;
            this.minMeasuredChildHeight &#x3D; undefined;
        }

        this.refresh_internal(false);
    }

    public scrollInto(item: any, alignToBeginning: boolean &#x3D; true, additionalOffset: number &#x3D; 0, animationMilliseconds: number &#x3D; undefined, animationCompletedCallback: () &#x3D;&gt; void &#x3D; undefined): void {
        const index: number &#x3D; this.items.indexOf(item);
        if (index &#x3D;&#x3D;&#x3D; -1) {
            return;
        }

        this.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);
    }

    public scrollToIndex(index: number, alignToBeginning: boolean &#x3D; true, additionalOffset: number &#x3D; 0, animationMilliseconds: number &#x3D; undefined, animationCompletedCallback: () &#x3D;&gt; void &#x3D; undefined): void {
        let maxRetries &#x3D; 5;

        const retryIfNeeded &#x3D; () &#x3D;&gt; {
            --maxRetries;
            if (maxRetries &lt;&#x3D; 0) {
                if (animationCompletedCallback) {
                    animationCompletedCallback();
                }
                return;
            }

            const dimensions &#x3D; this.calculateDimensions();
            const desiredStartIndex &#x3D; Math.min(Math.max(index, 0), dimensions.itemCount - 1);
            if (this.previousViewPort.startIndex &#x3D;&#x3D;&#x3D; desiredStartIndex) {
                if (animationCompletedCallback) {
                    animationCompletedCallback();
                }
                return;
            }

            this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, 0, retryIfNeeded);
        };

        this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, animationMilliseconds, retryIfNeeded);
    }

    protected scrollToIndex_internal(index: number, alignToBeginning: boolean &#x3D; true, additionalOffset: number &#x3D; 0, animationMilliseconds: number &#x3D; undefined, animationCompletedCallback: () &#x3D;&gt; void &#x3D; undefined): void {
        animationMilliseconds &#x3D; animationMilliseconds &#x3D;&#x3D;&#x3D; undefined ? this.scrollAnimationTime : animationMilliseconds;

        const dimensions &#x3D; this.calculateDimensions();
        let scroll &#x3D; this.calculatePadding(index, dimensions) + additionalOffset;
        if (!alignToBeginning) {
            scroll -&#x3D; dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];
        }

        this.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback);
    }

    public scrollToPosition(scrollPosition: number, animationMilliseconds: number &#x3D; undefined, animationCompletedCallback: () &#x3D;&gt; void &#x3D; undefined): void {
        scrollPosition +&#x3D; this.getElementsOffset();

        animationMilliseconds &#x3D; animationMilliseconds &#x3D;&#x3D;&#x3D; undefined ? this.scrollAnimationTime : animationMilliseconds;

        const scrollElement &#x3D; this.getScrollElement();

        let animationRequest: number;

        if (this.currentTween) {
            this.currentTween.stop();
            this.currentTween &#x3D; undefined;
        }

        if (!animationMilliseconds) {
            this.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);
            this.refresh_internal(false, animationCompletedCallback);
            return;
        }

        const tweenConfigObj &#x3D; { scrollPosition: scrollElement[this._scrollType] };

        const newTween &#x3D; new tween.Tween(tweenConfigObj)
            .to({ scrollPosition }, animationMilliseconds)
            .easing(tween.Easing.Quadratic.Out)
            .onUpdate((data) &#x3D;&gt; {
                if (isNaN(data.scrollPosition)) {
                    return;
                }
                this.renderer.setProperty(scrollElement, this._scrollType, data.scrollPosition);
                this.refresh_internal(false);
            })
            .onStop(() &#x3D;&gt; {
                cancelAnimationFrame(animationRequest);
            })
            .start();

        const animate &#x3D; (time?: number) &#x3D;&gt; {
            if (!newTween[&#x27;isPlaying&#x27;]()) {
                return;
            }

            newTween.update(time);
            if (tweenConfigObj.scrollPosition &#x3D;&#x3D;&#x3D; scrollPosition) {
                this.refresh_internal(false, animationCompletedCallback);
                return;
            }

            this.zone.runOutsideAngular(() &#x3D;&gt; {
                animationRequest &#x3D; requestAnimationFrame(animate);
            });
        };

        animate();
        this.currentTween &#x3D; newTween;
    }

    protected isAngularUniversalSSR: boolean;

    constructor(protected readonly element: ElementRef,
        protected readonly renderer: Renderer2,
        protected readonly zone: NgZone,
        protected changeDetectorRef: ChangeDetectorRef,
        @Inject(PLATFORM_ID) platformId: Object,
        @Optional() @Inject(&#x27;virtual-scroller-default-options&#x27;)
        options: VirtualScrollerDefaultOptions) {

        this.isAngularUniversalSSR &#x3D; isPlatformServer(platformId);

        this.scrollThrottlingTime &#x3D; options.scrollThrottlingTime;
        this.scrollDebounceTime &#x3D; options.scrollDebounceTime;
        this.scrollAnimationTime &#x3D; options.scrollAnimationTime;
        this.scrollbarWidth &#x3D; options.scrollbarWidth;
        this.scrollbarHeight &#x3D; options.scrollbarHeight;
        this.checkResizeInterval &#x3D; options.checkResizeInterval;
        this.resizeBypassRefreshThreshold &#x3D; options.resizeBypassRefreshThreshold;
        this.modifyOverflowStyleOfParentScroll &#x3D; options.modifyOverflowStyleOfParentScroll;
        this.stripedTable &#x3D; options.stripedTable;

        this.horizontal &#x3D; false;
        this.resetWrapGroupDimensions();
    }

    protected getElementSize(element: HTMLElement): ClientRect {
        const result &#x3D; element.getBoundingClientRect();
        const styles &#x3D; getComputedStyle(element);
        const marginTop &#x3D; parseInt(styles[&#x27;margin-top&#x27;], 10) || 0;
        const marginBottom &#x3D; parseInt(styles[&#x27;margin-bottom&#x27;], 10) || 0;
        const marginLeft &#x3D; parseInt(styles[&#x27;margin-left&#x27;], 10) || 0;
        const marginRight &#x3D; parseInt(styles[&#x27;margin-right&#x27;], 10) || 0;

        return {
            top: result.top + marginTop,
            bottom: result.bottom + marginBottom,
            left: result.left + marginLeft,
            right: result.right + marginRight,
            width: result.width + marginLeft + marginRight,
            height: result.height + marginTop + marginBottom
        };
    }

    protected previousScrollBoundingRect: ClientRect;
    protected checkScrollElementResized(): void {
        const boundingRect &#x3D; this.getElementSize(this.getScrollElement());

        let sizeChanged: boolean;
        if (!this.previousScrollBoundingRect) {
            sizeChanged &#x3D; true;
        } else {
            const widthChange &#x3D; Math.abs(boundingRect.width - this.previousScrollBoundingRect.width);
            const heightChange &#x3D; Math.abs(boundingRect.height - this.previousScrollBoundingRect.height);
            sizeChanged &#x3D; widthChange &gt; this.resizeBypassRefreshThreshold || heightChange &gt; this.resizeBypassRefreshThreshold;
        }

        if (sizeChanged) {
            this.previousScrollBoundingRect &#x3D; boundingRect;
            if (boundingRect.width &gt; 0 &amp;&amp; boundingRect.height &gt; 0) {
                this.refresh_internal(false);
            }
        }
    }

    protected _invisiblePaddingProperty;
    protected _offsetType;
    protected _scrollType;
    protected _pageOffsetType;
    protected _childScrollDim;
    protected _translateDir;
    protected _marginDir;
    protected updateDirection(): void {
        if (this.horizontal) {
            this._invisiblePaddingProperty &#x3D; &#x27;width&#x27;;
            this._offsetType &#x3D; &#x27;offsetLeft&#x27;;
            this._pageOffsetType &#x3D; &#x27;pageXOffset&#x27;;
            this._childScrollDim &#x3D; &#x27;childWidth&#x27;;
            this._marginDir &#x3D; &#x27;margin-left&#x27;;
            this._translateDir &#x3D; &#x27;translateX&#x27;;
            this._scrollType &#x3D; &#x27;scrollLeft&#x27;;
        } else {
            this._invisiblePaddingProperty &#x3D; &#x27;height&#x27;;
            this._offsetType &#x3D; &#x27;offsetTop&#x27;;
            this._pageOffsetType &#x3D; &#x27;pageYOffset&#x27;;
            this._childScrollDim &#x3D; &#x27;childHeight&#x27;;
            this._marginDir &#x3D; &#x27;margin-top&#x27;;
            this._translateDir &#x3D; &#x27;translateY&#x27;;
            this._scrollType &#x3D; &#x27;scrollTop&#x27;;
        }
    }

    protected debounce(func: Function, wait: number): Function {
        const throttled &#x3D; this.throttleTrailing(func, wait);
        const result &#x3D; function () {
            throttled[&#x27;cancel&#x27;]();
            throttled.apply(this, arguments);
        };
        result[&#x27;cancel&#x27;] &#x3D; function () {
            throttled[&#x27;cancel&#x27;]();
        };

        return result;
    }

    protected throttleTrailing(func: Function, wait: number): Function {
        let timeout;
        let _arguments &#x3D; arguments;
        const result &#x3D; function () {
            const _this &#x3D; this;
            _arguments &#x3D; arguments;

            if (timeout) {
                return;
            }

            if (wait &lt;&#x3D; 0) {
                func.apply(_this, _arguments);
            } else {
                timeout &#x3D; setTimeout(function () {
                    timeout &#x3D; undefined;
                    func.apply(_this, _arguments);
                }, wait);
            }
        };
        result[&#x27;cancel&#x27;] &#x3D; function () {
            if (timeout) {
                clearTimeout(timeout);
                timeout &#x3D; undefined;
            }
        };

        return result;
    }

    protected calculatedScrollbarWidth &#x3D; 0;
    protected calculatedScrollbarHeight &#x3D; 0;

    protected padding &#x3D; 0;
    protected previousViewPort: IViewport &#x3D; &lt;any&gt;{};
    protected currentTween: tween.Tween;
    protected cachedItemsLength: number;

    protected disposeScrollHandler: () &#x3D;&gt; void | undefined;
    protected disposeResizeHandler: () &#x3D;&gt; void | undefined;

    protected refresh_internal(itemsArrayModified: boolean, refreshCompletedCallback: () &#x3D;&gt; void &#x3D; undefined, maxRunTimes: number &#x3D; 2): void {
        // note: maxRunTimes is to force it to keep recalculating if the previous iteration caused a re-render (different sliced items in viewport or scrollPosition changed).
        // The default of 2x max will probably be accurate enough without causing too large a performance bottleneck
        // The code would typically quit out on the 2nd iteration anyways. The main time it&#x27;d think more than 2 runs would be necessary would be for vastly different sized child items or if this is the 1st time the items array was initialized.
        // Without maxRunTimes, If the user is actively scrolling this code would become an infinite loop until they stopped scrolling. This would be okay, except each scroll event would start an additional infinte loop. We want to short-circuit it to prevent this.

        if (itemsArrayModified &amp;&amp; this.previousViewPort &amp;&amp; this.previousViewPort.scrollStartPosition &gt; 0) {
            // if items were prepended, scroll forward to keep same items visible
            const oldViewPort &#x3D; this.previousViewPort;
            const oldViewPortItems &#x3D; this.viewPortItems;

            const oldRefreshCompletedCallback &#x3D; refreshCompletedCallback;
            refreshCompletedCallback &#x3D; () &#x3D;&gt; {
                const scrollLengthDelta &#x3D; this.previousViewPort.scrollLength - oldViewPort.scrollLength;
                if (scrollLengthDelta &gt; 0 &amp;&amp; this.viewPortItems) {
                    const oldStartItem &#x3D; oldViewPortItems[0];
                    const oldStartItemIndex &#x3D; this.items.findIndex(x &#x3D;&gt; this.compareItems(oldStartItem, x));
                    if (oldStartItemIndex &gt; this.previousViewPort.startIndexWithBuffer) {
                        let itemOrderChanged &#x3D; false;
                        for (let i &#x3D; 1; i &lt; this.viewPortItems.length; ++i) {
                            if (!this.compareItems(this.items[oldStartItemIndex + i], oldViewPortItems[i])) {
                                itemOrderChanged &#x3D; true;
                                break;
                            }
                        }

                        if (!itemOrderChanged) {
                            this.scrollToPosition(this.previousViewPort.scrollStartPosition + scrollLengthDelta, 0, oldRefreshCompletedCallback);
                            return;
                        }
                    }
                }

                if (oldRefreshCompletedCallback) {
                    oldRefreshCompletedCallback();
                }
            };
        }

        this.zone.runOutsideAngular(() &#x3D;&gt; {
            requestAnimationFrame(() &#x3D;&gt; {

                if (itemsArrayModified) {
                    this.resetWrapGroupDimensions();
                }
                const viewport &#x3D; this.calculateViewport();

                const startChanged &#x3D; itemsArrayModified || viewport.startIndex !&#x3D;&#x3D; this.previousViewPort.startIndex;
                const endChanged &#x3D; itemsArrayModified || viewport.endIndex !&#x3D;&#x3D; this.previousViewPort.endIndex;
                const scrollLengthChanged &#x3D; viewport.scrollLength !&#x3D;&#x3D; this.previousViewPort.scrollLength;
                const paddingChanged &#x3D; viewport.padding !&#x3D;&#x3D; this.previousViewPort.padding;
                const scrollPositionChanged &#x3D; viewport.scrollStartPosition !&#x3D;&#x3D; this.previousViewPort.scrollStartPosition || viewport.scrollEndPosition !&#x3D;&#x3D; this.previousViewPort.scrollEndPosition || viewport.maxScrollPosition !&#x3D;&#x3D; this.previousViewPort.maxScrollPosition;

                this.previousViewPort &#x3D; viewport;

                if (scrollLengthChanged) {
                    this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, this._invisiblePaddingProperty, &#x60;${viewport.scrollLength}px&#x60;);
                }

                if (paddingChanged) {
                    if (this.useMarginInsteadOfTranslate) {
                        this.renderer.setStyle(this.contentElementRef.nativeElement, this._marginDir, &#x60;${viewport.padding}px&#x60;);
                    } else {
                        this.renderer.setStyle(this.contentElementRef.nativeElement, &#x27;transform&#x27;, &#x60;${this._translateDir}(${viewport.padding}px)&#x60;);
                        this.renderer.setStyle(this.contentElementRef.nativeElement, &#x27;webkitTransform&#x27;, &#x60;${this._translateDir}(${viewport.padding}px)&#x60;);
                    }
                }

                if (this.headerElementRef) {
                    const scrollPosition &#x3D; this.getScrollElement()[this._scrollType];
                    const containerOffset &#x3D; this.getElementsOffset();
                    const offset &#x3D; Math.max(scrollPosition - viewport.padding - containerOffset + this.headerElementRef.nativeElement.clientHeight, 0);
                    this.renderer.setStyle(this.headerElementRef.nativeElement, &#x27;transform&#x27;, &#x60;${this._translateDir}(${offset}px)&#x60;);
                    this.renderer.setStyle(this.headerElementRef.nativeElement, &#x27;webkitTransform&#x27;, &#x60;${this._translateDir}(${offset}px)&#x60;);
                }

                const changeEventArg: IPageInfo &#x3D; (startChanged || endChanged) ? {
                    startIndex: viewport.startIndex,
                    endIndex: viewport.endIndex,
                    scrollStartPosition: viewport.scrollStartPosition,
                    scrollEndPosition: viewport.scrollEndPosition,
                    startIndexWithBuffer: viewport.startIndexWithBuffer,
                    endIndexWithBuffer: viewport.endIndexWithBuffer,
                    maxScrollPosition: viewport.maxScrollPosition
                } : undefined;


                if (startChanged || endChanged || scrollPositionChanged) {
                    const handleChanged &#x3D; () &#x3D;&gt; {
                        // update the scroll list to trigger re-render of components in viewport
                        this.viewPortItems &#x3D; viewport.startIndexWithBuffer &gt;&#x3D; 0 &amp;&amp; viewport.endIndexWithBuffer &gt;&#x3D; 0 ? this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];
                        this.vsUpdate.emit(this.viewPortItems);

                        if (startChanged) {
                            this.vsStart.emit(changeEventArg);
                        }

                        if (endChanged) {
                            this.vsEnd.emit(changeEventArg);
                        }

                        if (startChanged || endChanged) {
                            this.changeDetectorRef.markForCheck();
                            this.vsChange.emit(changeEventArg);
                        }

                        if (maxRunTimes &gt; 0) {
                            this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);
                            return;
                        }

                        if (refreshCompletedCallback) {
                            refreshCompletedCallback();
                        }
                    };


                    if (this.executeRefreshOutsideAngularZone) {
                        handleChanged();
                    } else {
                        this.zone.run(handleChanged);
                    }
                } else {
                    if (maxRunTimes &gt; 0 &amp;&amp; (scrollLengthChanged || paddingChanged)) {
                        this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);
                        return;
                    }

                    if (refreshCompletedCallback) {
                        refreshCompletedCallback();
                    }
                }
            });
        });
    }

    protected getScrollElement(): HTMLElement {
        return this.parentScroll instanceof Window ? document.scrollingElement || document.documentElement || document.body : this.parentScroll || this.element.nativeElement;
    }

    protected addScrollEventHandlers(): void {
        if (this.isAngularUniversalSSR) {
            return;
        }

        const scrollElement &#x3D; this.getScrollElement();

        this.removeScrollEventHandlers();

        this.zone.runOutsideAngular(() &#x3D;&gt; {
            if (this.parentScroll instanceof Window) {
                this.disposeScrollHandler &#x3D; this.renderer.listen(&#x27;window&#x27;, &#x27;scroll&#x27;, this.onScroll);
                this.disposeResizeHandler &#x3D; this.renderer.listen(&#x27;window&#x27;, &#x27;resize&#x27;, this.onScroll);
            } else {
                this.disposeScrollHandler &#x3D; this.renderer.listen(scrollElement, &#x27;scroll&#x27;, this.onScroll);
                if (this._checkResizeInterval &gt; 0) {
                    this.checkScrollElementResizedTimer &#x3D; &lt;any&gt;setInterval(() &#x3D;&gt; { this.checkScrollElementResized(); }, this._checkResizeInterval);
                }
            }
        });
    }

    protected removeScrollEventHandlers(): void {
        if (this.checkScrollElementResizedTimer) {
            clearInterval(this.checkScrollElementResizedTimer);
        }

        if (this.disposeScrollHandler) {
            this.disposeScrollHandler();
            this.disposeScrollHandler &#x3D; undefined;
        }

        if (this.disposeResizeHandler) {
            this.disposeResizeHandler();
            this.disposeResizeHandler &#x3D; undefined;
        }
    }

    protected getElementsOffset(): number {
        if (this.isAngularUniversalSSR) {
            return 0;
        }

        let offset &#x3D; 0;

        if (this.containerElementRef &amp;&amp; this.containerElementRef.nativeElement) {
            offset +&#x3D; this.containerElementRef.nativeElement[this._offsetType];
        }

        if (this.parentScroll) {
            const scrollElement &#x3D; this.getScrollElement();
            const elementClientRect &#x3D; this.getElementSize(this.element.nativeElement);
            const scrollClientRect &#x3D; this.getElementSize(scrollElement);
            if (this.horizontal) {
                offset +&#x3D; elementClientRect.left - scrollClientRect.left;
            } else {
                offset +&#x3D; elementClientRect.top - scrollClientRect.top;
            }

            if (!(this.parentScroll instanceof Window)) {
                offset +&#x3D; scrollElement[this._scrollType];
            }
        }

        return offset;
    }

    protected countItemsPerWrapGroup(): number {
        if (this.isAngularUniversalSSR) {
            return Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);
        }

        const propertyName &#x3D; this.horizontal ? &#x27;offsetLeft&#x27; : &#x27;offsetTop&#x27;;
        const children &#x3D; ((this.containerElementRef &amp;&amp; this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement).children;

        const childrenLength &#x3D; children ? children.length : 0;
        if (childrenLength &#x3D;&#x3D;&#x3D; 0) {
            return 1;
        }

        const firstOffset &#x3D; children[0][propertyName];
        let result &#x3D; 1;
        while (result &lt; childrenLength &amp;&amp; firstOffset &#x3D;&#x3D;&#x3D; children[result][propertyName]) {
            ++result;
        }

        return result;
    }

    protected getScrollStartPosition(): number {
        let windowScrollValue;
        if (this.parentScroll instanceof Window) {
            windowScrollValue &#x3D; window[this._pageOffsetType];
        }

        return windowScrollValue || this.getScrollElement()[this._scrollType] || 0;
    }

    protected minMeasuredChildWidth: number;
    protected minMeasuredChildHeight: number;

    protected wrapGroupDimensions: WrapGroupDimensions;

    protected resetWrapGroupDimensions(): void {
        const oldWrapGroupDimensions &#x3D; this.wrapGroupDimensions;
        this.invalidateAllCachedMeasurements();

        if (!this.enableUnequalChildrenSizes || !oldWrapGroupDimensions || oldWrapGroupDimensions.numberOfKnownWrapGroupChildSizes &#x3D;&#x3D;&#x3D; 0) {
            return;
        }

        const itemsPerWrapGroup: number &#x3D; this.countItemsPerWrapGroup();
        for (let wrapGroupIndex &#x3D; 0; wrapGroupIndex &lt; oldWrapGroupDimensions.maxChildSizePerWrapGroup.length; ++wrapGroupIndex) {
            const oldWrapGroupDimension: WrapGroupDimension &#x3D; oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];
            if (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {
                continue;
            }

            if (oldWrapGroupDimension.items.length !&#x3D;&#x3D; itemsPerWrapGroup) {
                return;
            }

            let itemsChanged &#x3D; false;
            const arrayStartIndex &#x3D; itemsPerWrapGroup * wrapGroupIndex;
            for (let i &#x3D; 0; i &lt; itemsPerWrapGroup; ++i) {
                if (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {
                    itemsChanged &#x3D; true;
                    break;
                }
            }

            if (!itemsChanged) {
                ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths +&#x3D; oldWrapGroupDimension.childWidth || 0;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights +&#x3D; oldWrapGroupDimension.childHeight || 0;
                this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] &#x3D; oldWrapGroupDimension;
            }
        }
    }

    protected calculateDimensions(): IDimensions {
        const scrollElement &#x3D; this.getScrollElement();

        const maxCalculatedScrollBarSize &#x3D; 25; // Note: Formula to auto-calculate doesn&#x27;t work for ParentScroll, so we default to this if not set by consuming application
        this.calculatedScrollbarHeight &#x3D; Math.max(Math.min(scrollElement.offsetHeight - scrollElement.clientHeight, maxCalculatedScrollBarSize), this.calculatedScrollbarHeight);
        this.calculatedScrollbarWidth &#x3D; Math.max(Math.min(scrollElement.offsetWidth - scrollElement.clientWidth, maxCalculatedScrollBarSize), this.calculatedScrollbarWidth);

        let viewportWidth &#x3D; scrollElement.offsetWidth - (this.scrollbarWidth || this.calculatedScrollbarWidth || (this.horizontal ? 0 : maxCalculatedScrollBarSize));
        let viewportHeight &#x3D; scrollElement.offsetHeight - (this.scrollbarHeight || this.calculatedScrollbarHeight || (this.horizontal ? maxCalculatedScrollBarSize : 0));

        const content &#x3D; (this.containerElementRef &amp;&amp; this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement;

        const itemsPerWrapGroup &#x3D; this.countItemsPerWrapGroup();
        let wrapGroupsPerPage;

        let defaultChildWidth;
        let defaultChildHeight;

        if (this.isAngularUniversalSSR) {
            viewportWidth &#x3D; this.ssrViewportWidth;
            viewportHeight &#x3D; this.ssrViewportHeight;
            defaultChildWidth &#x3D; this.ssrChildWidth;
            defaultChildHeight &#x3D; this.ssrChildHeight;
            const itemsPerRow &#x3D; Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);
            const itemsPerCol &#x3D; Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);
            wrapGroupsPerPage &#x3D; this.horizontal ? itemsPerRow : itemsPerCol;
        } else if (!this.enableUnequalChildrenSizes) {
            if (content.children.length &gt; 0) {
                if (!this.childWidth || !this.childHeight) {
                    if (!this.minMeasuredChildWidth &amp;&amp; viewportWidth &gt; 0) {
                        this.minMeasuredChildWidth &#x3D; viewportWidth;
                    }
                    if (!this.minMeasuredChildHeight &amp;&amp; viewportHeight &gt; 0) {
                        this.minMeasuredChildHeight &#x3D; viewportHeight;
                    }
                }

                const child &#x3D; content.children[0];
                const clientRect &#x3D; this.getElementSize(child);
                this.minMeasuredChildWidth &#x3D; Math.min(this.minMeasuredChildWidth, clientRect.width);
                this.minMeasuredChildHeight &#x3D; Math.min(this.minMeasuredChildHeight, clientRect.height);
            }

            defaultChildWidth &#x3D; this.childWidth || this.minMeasuredChildWidth || viewportWidth;
            defaultChildHeight &#x3D; this.childHeight || this.minMeasuredChildHeight || viewportHeight;
            const itemsPerRow &#x3D; Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);
            const itemsPerCol &#x3D; Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);
            wrapGroupsPerPage &#x3D; this.horizontal ? itemsPerRow : itemsPerCol;
        } else {
            let scrollOffset &#x3D; scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);

            let arrayStartIndex &#x3D; this.previousViewPort.startIndexWithBuffer || 0;
            let wrapGroupIndex &#x3D; Math.ceil(arrayStartIndex / itemsPerWrapGroup);

            let maxWidthForWrapGroup &#x3D; 0;
            let maxHeightForWrapGroup &#x3D; 0;
            let sumOfVisibleMaxWidths &#x3D; 0;
            let sumOfVisibleMaxHeights &#x3D; 0;
            wrapGroupsPerPage &#x3D; 0;

            for (let i &#x3D; 0; i &lt; content.children.length; ++i) {
                ++arrayStartIndex;
                const child &#x3D; content.children[i];
                const clientRect &#x3D; this.getElementSize(child);

                maxWidthForWrapGroup &#x3D; Math.max(maxWidthForWrapGroup, clientRect.width);
                maxHeightForWrapGroup &#x3D; Math.max(maxHeightForWrapGroup, clientRect.height);

                if (arrayStartIndex % itemsPerWrapGroup &#x3D;&#x3D;&#x3D; 0) {
                    const oldValue &#x3D; this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];
                    if (oldValue) {
                        --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -&#x3D; oldValue.childWidth || 0;
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -&#x3D; oldValue.childHeight || 0;
                    }

                    ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                    const items &#x3D; this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex);
                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] &#x3D; {
                        childWidth: maxWidthForWrapGroup,
                        childHeight: maxHeightForWrapGroup,
                        items: items
                    };
                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths +&#x3D; maxWidthForWrapGroup;
                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights +&#x3D; maxHeightForWrapGroup;

                    if (this.horizontal) {
                        let maxVisibleWidthForWrapGroup &#x3D; Math.min(maxWidthForWrapGroup, Math.max(viewportWidth - sumOfVisibleMaxWidths, 0));
                        if (scrollOffset &gt; 0) {
                            const scrollOffsetToRemove &#x3D; Math.min(scrollOffset, maxVisibleWidthForWrapGroup);
                            maxVisibleWidthForWrapGroup -&#x3D; scrollOffsetToRemove;
                            scrollOffset -&#x3D; scrollOffsetToRemove;
                        }

                        sumOfVisibleMaxWidths +&#x3D; maxVisibleWidthForWrapGroup;
                        if (maxVisibleWidthForWrapGroup &gt; 0 &amp;&amp; viewportWidth &gt;&#x3D; sumOfVisibleMaxWidths) {
                            ++wrapGroupsPerPage;
                        }
                    } else {
                        let maxVisibleHeightForWrapGroup &#x3D; Math.min(maxHeightForWrapGroup, Math.max(viewportHeight - sumOfVisibleMaxHeights, 0));
                        if (scrollOffset &gt; 0) {
                            const scrollOffsetToRemove &#x3D; Math.min(scrollOffset, maxVisibleHeightForWrapGroup);
                            maxVisibleHeightForWrapGroup -&#x3D; scrollOffsetToRemove;
                            scrollOffset -&#x3D; scrollOffsetToRemove;
                        }

                        sumOfVisibleMaxHeights +&#x3D; maxVisibleHeightForWrapGroup;
                        if (maxVisibleHeightForWrapGroup &gt; 0 &amp;&amp; viewportHeight &gt;&#x3D; sumOfVisibleMaxHeights) {
                            ++wrapGroupsPerPage;
                        }
                    }

                    ++wrapGroupIndex;

                    maxWidthForWrapGroup &#x3D; 0;
                    maxHeightForWrapGroup &#x3D; 0;
                }
            }

            const averageChildWidth &#x3D; this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
            const averageChildHeight &#x3D; this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
            defaultChildWidth &#x3D; this.childWidth || averageChildWidth || viewportWidth;
            defaultChildHeight &#x3D; this.childHeight || averageChildHeight || viewportHeight;

            if (this.horizontal) {
                if (viewportWidth &gt; sumOfVisibleMaxWidths) {
                    wrapGroupsPerPage +&#x3D; Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth);
                }
            } else {
                if (viewportHeight &gt; sumOfVisibleMaxHeights) {
                    wrapGroupsPerPage +&#x3D; Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight);
                }
            }
        }

        const itemCount &#x3D; this.items.length;
        const itemsPerPage &#x3D; itemsPerWrapGroup * wrapGroupsPerPage;
        const pageCount_fractional &#x3D; itemCount / itemsPerPage;
        const numberOfWrapGroups &#x3D; Math.ceil(itemCount / itemsPerWrapGroup);

        let scrollLength &#x3D; 0;

        const defaultScrollLengthPerWrapGroup &#x3D; this.horizontal ? defaultChildWidth : defaultChildHeight;
        if (this.enableUnequalChildrenSizes) {
            let numUnknownChildSizes &#x3D; 0;
            for (let i &#x3D; 0; i &lt; numberOfWrapGroups; ++i) {
                const childSize &#x3D; this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] &amp;&amp; this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                if (childSize) {
                    scrollLength +&#x3D; childSize;
                } else {
                    ++numUnknownChildSizes;
                }
            }

            scrollLength +&#x3D; Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);
        } else {
            scrollLength &#x3D; numberOfWrapGroups * defaultScrollLengthPerWrapGroup;
        }

        if (this.headerElementRef) {
            scrollLength +&#x3D; this.headerElementRef.nativeElement.clientHeight;
        }

        const viewportLength &#x3D; this.horizontal ? viewportWidth : viewportHeight;
        const maxScrollPosition &#x3D; Math.max(scrollLength - viewportLength, 0);

        return {
            itemCount: itemCount,
            itemsPerWrapGroup: itemsPerWrapGroup,
            wrapGroupsPerPage: wrapGroupsPerPage,
            itemsPerPage: itemsPerPage,
            pageCount_fractional: pageCount_fractional,
            childWidth: defaultChildWidth,
            childHeight: defaultChildHeight,
            scrollLength: scrollLength,
            viewportLength: viewportLength,
            maxScrollPosition: maxScrollPosition
        };
    }

    protected cachedPageSize &#x3D; 0;
    protected previousScrollNumberElements &#x3D; 0;

    protected calculatePadding(arrayStartIndexWithBuffer: number, dimensions: IDimensions): number {
        if (dimensions.itemCount &#x3D;&#x3D;&#x3D; 0) {
            return 0;
        }

        const defaultScrollLengthPerWrapGroup &#x3D; dimensions[this._childScrollDim];
        const startingWrapGroupIndex &#x3D; Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;

        if (!this.enableUnequalChildrenSizes) {
            return defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;
        }

        let numUnknownChildSizes &#x3D; 0;
        let result &#x3D; 0;
        for (let i &#x3D; 0; i &lt; startingWrapGroupIndex; ++i) {
            const childSize &#x3D; this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] &amp;&amp; this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
            if (childSize) {
                result +&#x3D; childSize;
            } else {
                ++numUnknownChildSizes;
            }
        }
        result +&#x3D; Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);

        return result;
    }

    protected calculatePageInfo(scrollPosition: number, dimensions: IDimensions): IPageInfo {
        let scrollPercentage &#x3D; 0;
        if (this.enableUnequalChildrenSizes) {
            const numberOfWrapGroups &#x3D; Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);
            let totalScrolledLength &#x3D; 0;
            const defaultScrollLengthPerWrapGroup &#x3D; dimensions[this._childScrollDim];
            for (let i &#x3D; 0; i &lt; numberOfWrapGroups; ++i) {
                const childSize &#x3D; this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] &amp;&amp; this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                if (childSize) {
                    totalScrolledLength +&#x3D; childSize;
                } else {
                    totalScrolledLength +&#x3D; defaultScrollLengthPerWrapGroup;
                }

                if (scrollPosition &lt; totalScrolledLength) {
                    scrollPercentage &#x3D; i / numberOfWrapGroups;
                    break;
                }
            }
        } else {
            scrollPercentage &#x3D; scrollPosition / dimensions.scrollLength;
        }

        const startingArrayIndex_fractional &#x3D; Math.min(Math.max(scrollPercentage * dimensions.pageCount_fractional, 0), dimensions.pageCount_fractional) * dimensions.itemsPerPage;

        const maxStart &#x3D; dimensions.itemCount - dimensions.itemsPerPage - 1;
        let arrayStartIndex &#x3D; Math.min(Math.floor(startingArrayIndex_fractional), maxStart);
        arrayStartIndex -&#x3D; arrayStartIndex % dimensions.itemsPerWrapGroup; // round down to start of wrapGroup

        if (this.stripedTable) {
            const bufferBoundary &#x3D; 2 * dimensions.itemsPerWrapGroup;
            if (arrayStartIndex % bufferBoundary !&#x3D;&#x3D; 0) {
                arrayStartIndex &#x3D; Math.max(arrayStartIndex - arrayStartIndex % bufferBoundary, 0);
            }
        }

        let arrayEndIndex &#x3D; Math.ceil(startingArrayIndex_fractional) + dimensions.itemsPerPage - 1;
        const endIndexWithinWrapGroup &#x3D; (arrayEndIndex + 1) % dimensions.itemsPerWrapGroup;
        if (endIndexWithinWrapGroup &gt; 0) {
            arrayEndIndex +&#x3D; dimensions.itemsPerWrapGroup - endIndexWithinWrapGroup; // round up to end of wrapGroup
        }

        if (isNaN(arrayStartIndex)) {
            arrayStartIndex &#x3D; 0;
        }
        if (isNaN(arrayEndIndex)) {
            arrayEndIndex &#x3D; 0;
        }

        arrayStartIndex &#x3D; Math.min(Math.max(arrayStartIndex, 0), dimensions.itemCount - 1);
        arrayEndIndex &#x3D; Math.min(Math.max(arrayEndIndex, 0), dimensions.itemCount - 1);

        const bufferSize &#x3D; this.bufferAmount * dimensions.itemsPerWrapGroup;
        const startIndexWithBuffer &#x3D; Math.min(Math.max(arrayStartIndex - bufferSize, 0), dimensions.itemCount - 1);
        const endIndexWithBuffer &#x3D; Math.min(Math.max(arrayEndIndex + bufferSize, 0), dimensions.itemCount - 1);

        return {
            startIndex: arrayStartIndex,
            endIndex: arrayEndIndex,
            startIndexWithBuffer: startIndexWithBuffer,
            endIndexWithBuffer: endIndexWithBuffer,
            scrollStartPosition: scrollPosition,
            scrollEndPosition: scrollPosition + dimensions.viewportLength,
            maxScrollPosition: dimensions.maxScrollPosition
        };
    }

    protected calculateViewport(): IViewport {
        const dimensions &#x3D; this.calculateDimensions();
        const offset &#x3D; this.getElementsOffset();

        let scrollStartPosition &#x3D; this.getScrollStartPosition();
        if (scrollStartPosition &gt; (dimensions.scrollLength + offset) &amp;&amp; !(this.parentScroll instanceof Window)) {
            scrollStartPosition &#x3D; dimensions.scrollLength;
        } else {
            scrollStartPosition -&#x3D; offset;
        }
        scrollStartPosition &#x3D; Math.max(0, scrollStartPosition);

        const pageInfo &#x3D; this.calculatePageInfo(scrollStartPosition, dimensions);
        const newPadding &#x3D; this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions);
        const newScrollLength &#x3D; dimensions.scrollLength;

        return {
            startIndex: pageInfo.startIndex,
            endIndex: pageInfo.endIndex,
            startIndexWithBuffer: pageInfo.startIndexWithBuffer,
            endIndexWithBuffer: pageInfo.endIndexWithBuffer,
            padding: Math.round(newPadding),
            scrollLength: Math.round(newScrollLength),
            scrollStartPosition: pageInfo.scrollStartPosition,
            scrollEndPosition: pageInfo.scrollEndPosition,
            maxScrollPosition: pageInfo.maxScrollPosition
        };
    }
}

@NgModule({
    exports: [VirtualScrollerComponent],
    declarations: [VirtualScrollerComponent],
    imports: [CommonModule],
    providers: [
        {
            provide: &#x27;virtual-scroller-default-options&#x27;,
            useFactory: VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY
        }
    ]
})
export class VirtualScrollerModule { }
</code></pre>
    </div>
</div>










                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'module';
            var COMPODOC_CURRENT_PAGE_URL = 'VirtualScrollerModule.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
